---
outline: deep
---

# 什么是 ilias?

ilias 是一个现代化的基于完成的异步运行时, 它旨在给开发者提供类似tokio一样的爽快开发体验和性能, 同时兼顾与其他异步生态的互操作性.

## 为什么新造轮子?

我之前在写我的Qt应用时候编写网络相关代码, 我陷入了回调地狱

每次我需要处理一个网络请求, 我必须写一个回调函数, 然后把他连接到Qt的信号里面
我发现如果逻辑越来越复杂, 这个回调地狱会变得难以维护, 生命周期也几乎不可控, 需要使用shared_ptr, 我于是目光转向了现有的协程库

cppcoro 这个库算是C++20无栈协程的先驱, 但是好久没有维护了, 而且网络部分只支持Windows

asio 这个是老牌的异步库, 但是协程部分的取消强制依赖异常, 我不是很希望使用异常来处理取消, 应为异常跨越await点就要rethrow + catch 我觉得比较低效

folly seastar 先进, 但是很重

于是我把目光投向了rust, 看到了隔壁的tokio 发现他的接口设计的比较不错, 并且有丰富的生态, 但是实际体验的时候发现取消和有些地方稍微不是符合我的胃口, 默认spawn需要Send + Sync, 然后在这个时候我看到了std::execution 我发现它的取消的设计非常不错和安全, 结构化并发, 于是说干就干, 在参考tokio和stdexec的理念后, 就有了ilias, 我想让我自己开发异步程序不再痛苦, 可以使用C++写出快速安全的程序并兼容现有的生态

## 设计理念

- 每条线程一个调度器, 最简单的形式, 方便集成进其他异步生态, 而且先天无锁
- 基于完成 + 异步取消, 取消不是直接Drop, 他会发送取消信号, 然后异步等待底层取消完成
- 结构化并发, 由于基于完成和异步取消 可以实现TaskScope和finally 添加异步代码当取消清理的时候, 这大部分简化了生命周期的管理
- 尽量少的依赖, 我不希望用户使用这个库需要一堆附属的库
  